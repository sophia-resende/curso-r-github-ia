---
title: "Introdu√ß√£o Programa√ß√£o em R com GitHub, ChatGPT e Claude"
# subtitle: "An√°lise de Dados Moderna para Iniciantes"
author: "Vin√≠cius Silva Junqueira"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    latex_engine: xelatex
    toc: true
    toc_depth: 2
    number_sections: true
lang: pt-BR
fontsize: 11pt
geometry: margin=2.5cm
header-includes:
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[L]{\small Vin√≠cius Silva Junqueira}
  - \fancyhead[R]{\small \thepage}
  - \fancyfoot[L]{\small Curso R + GitHub + IA}
  - \fancyfoot[R]{\small junqueiravinicius@hotmail.com}
  - \renewcommand{\headrulewidth}{0.4pt}
  - \renewcommand{\footrulewidth}{0.4pt}
---

```{r setup, include=FALSE}
# ========================================
# CHUNK DE SETUP - N√ÉO APARECE NO PDF
# ========================================
# Este chunk define op√ß√µes globais e (se desejado) carrega pacotes.

knitr::opts_chunk$set(
  echo = TRUE,
  eval = FALSE,       # Deixe FALSE para exibir o c√≥digo em sala
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  comment = "#>"
)

# Descomente para executar de fato em sua m√°quina:
# library(tidyverse)
# library(lubridate)
# library(palmerpenguins)
```

# Dia 2 ‚Äî L√≥gica, Fun√ß√µes e Introdu√ß√£o ao Tidyverse

> **Objetivos do dia**
>
> - Dominar operadores l√≥gicos/relacionais e condicionais (`if`, `ifelse`, `case_when`).  
> - Entender loops vs. vetoriza√ß√£o e criar **fun√ß√µes pr√≥prias**.  
> - Aplicar um **pipeline b√°sico** com `dplyr` e introduzir **datas** com `lubridate`.  
> - Registrar o aprendizado com um commit no seu fork no GitHub.

**Tempo previsto** 19h00‚Äì22h00 (intervalo 20h30‚Äì20h50)

---

## 1. Operadores e Condicionais (‚âà 30 min)

### O que s√£o operadores?

**Operadores** s√£o s√≠mbolos especiais que realizam opera√ß√µes entre valores. Eles s√£o fundamentais para tomar decis√µes no c√≥digo e controlar o fluxo de execu√ß√£o.

### 1.1 Operadores l√≥gicos e relacionais

**Operadores relacionais** comparam dois valores e retornam `TRUE` ou `FALSE`:

- `==` : igual a
- `!=` : diferente de  
- `>` : maior que
- `<` : menor que
- `>=` : maior ou igual
- `<=` : menor ou igual

**Operadores l√≥gicos** combinam condi√ß√µes:

- `&` : E (AND) - ambas condi√ß√µes devem ser verdadeiras
- `|` : OU (OR) - pelo menos uma condi√ß√£o deve ser verdadeira
- `!` : N√ÉO (NOT) - inverte o valor l√≥gico
- `xor()` : OU EXCLUSIVO - apenas uma condi√ß√£o pode ser verdadeira

**Operador especial:**
- `%in%` : verifica se um valor est√° presente em um vetor

```{r}
# L√≥gicos: & | ! xor()
TRUE & FALSE    # FALSE (ambos precisam ser TRUE)
TRUE | FALSE    # TRUE (pelo menos um √© TRUE)
!TRUE          # FALSE (inverte)
xor(TRUE, FALSE) # TRUE (apenas um √© TRUE)

# Relacionais: == != > < >= <=
3 == 3         # TRUE (igual)
5 != 2         # TRUE (diferente)
5 > 2; 1 < 0   # TRUE; FALSE
2 >= 2; 3 <= 10 # TRUE; TRUE

# %in% (teste de pertin√™ncia)
2 %in% c(1, 2, 3)                        # TRUE
"Adelie" %in% c("Chinstrap", "Gentoo")   # FALSE
```

### 1.2 Condicionais: tomando decis√µes no c√≥digo

**Condicionais** permitem que seu c√≥digo tome decis√µes baseadas em condi√ß√µes. S√£o como perguntas "se... ent√£o... sen√£o...".

**Tr√™s formas principais:**

1. **`if/else`** - Estrutura cl√°ssica para **um √∫nico valor**
   - Avalia uma condi√ß√£o e executa diferentes blocos de c√≥digo
   - √ötil para controle de fluxo em fun√ß√µes
   
2. **`ifelse()`** - Vers√£o **vetorizada** para m√∫ltiplos valores
   - Aplica a condi√ß√£o a cada elemento de um vetor
   - Retorna um vetor de resultados
   - Ideal para criar novas colunas em data.frames

3. **`case_when()`** - Para **m√∫ltiplas condi√ß√µes** complexas
   - Avalia v√°rias regras em sequ√™ncia
   - Para na primeira regra verdadeira
   - Mais leg√≠vel que `ifelse()` aninhados

```{r}
# if/else (escalar - um valor por vez)
x <- 18
if (x >= 18) {
  status <- "maior_de_idade"
} else {
  status <- "menor_de_idade"
}
status

# ifelse() (vetorizado - m√∫ltiplos valores)
notas <- c(5.9, 7.5, 9.2, 6.0)
resultado <- ifelse(notas >= 7, "Aprovado", "Recupera√ß√£o")
resultado

# case_when() (m√∫ltiplas regras em ordem)
library(dplyr)
faixa <- case_when(
  notas >= 9             ~ "Excelente",
  notas >= 7 & notas < 9 ~ "Bom",
  notas >= 5 & notas < 7 ~ "Regular",
  TRUE                   ~ "Insuficiente"  # TRUE = "caso contr√°rio"
)
faixa
```

> **Dica did√°tica**: use `ifelse()` quando quiser **vetorizar**; `case_when()` quando houver **v√°rias regras**.

---

## 2. Loops, Vetoriza√ß√£o e Fun√ß√µes (‚âà 25 min)

### 2.1 Loops vs. opera√ß√µes vetorizadas

**O que s√£o loops?**

Um **loop** (la√ßo) √© uma estrutura que repete um bloco de c√≥digo v√°rias vezes. O loop `for` √© o mais comum e executa o c√≥digo uma vez para cada elemento de uma sequ√™ncia.

**Por que evitar loops em R?**

R √© uma linguagem **vetorizada**, o que significa que muitas opera√ß√µes funcionam automaticamente em vetores inteiros, sem precisar de loops expl√≠citos. Opera√ß√µes vetorizadas s√£o:
- **Mais r√°pidas** (otimizadas internamente em C/Fortran)
- **Mais leg√≠veis** (menos linhas de c√≥digo)
- **Mais idiom√°ticas** (o "jeito R" de fazer)

**Quando usar loops:**
- Quando n√£o existe alternativa vetorizada
- Para opera√ß√µes que dependem de itera√ß√µes anteriores
- Em simula√ß√µes e processos iterativos

```{r}
valores <- 1:5

# Loop for (did√°tico, mas n√£o idiom√°tico)
soma <- 0
for (v in valores) {
  soma <- soma + v
}
soma

# Vetorizado (preferido em R!)
sum(valores)  # Muito mais simples e r√°pido
```

### 2.2 Fun√ß√µes: empacotando l√≥gica reutiliz√°vel

**O que s√£o fun√ß√µes?**

**Fun√ß√µes** s√£o blocos de c√≥digo que realizam uma tarefa espec√≠fica e podem ser reutilizados. S√£o fundamentais para:
- **Organizar** c√≥digo em partes l√≥gicas
- **Reutilizar** l√≥gica sem repetir c√≥digo
- **Documentar** inten√ß√µes atrav√©s de nomes descritivos
- **Facilitar** manuten√ß√£o e debugging

**Estrutura de uma fun√ß√£o:**
```r
nome_funcao <- function(argumento1, argumento2 = valor_padrao) {
  # corpo da fun√ß√£o
  resultado <- alguma_operacao
  return(resultado)  # return √© opcional (retorna √∫ltima express√£o)
}
```

**Boas pr√°ticas:**
- Use nomes descritivos que indiquem o que a fun√ß√£o faz
- Valide entradas com `stop()`, `stopifnot()` ou `if`
- Documente com coment√°rios o que a fun√ß√£o faz e quais s√£o os argumentos
- Retorne sempre o mesmo tipo de objeto

**Exemplo pr√°tico: calculadora de IMC**

```{r}
# F√≥rmula: IMC = peso(kg) / altura(m)^2
imc <- function(peso, altura) {
  # Valida√ß√£o: altura n√£o pode ser zero ou negativa
  if (any(altura <= 0)) stop("Altura deve ser > 0")
  
  # C√°lculo vetorizado (funciona com um ou v√°rios valores)
  peso / (altura ^ 2)
}

# Testando com m√∫ltiplos valores
imc(c(70, 80), c(1.70, 1.80))

# Fun√ß√£o para classificar IMC usando case_when()
classificar_imc <- function(imc) {
  dplyr::case_when(
    imc < 18.5              ~ "Abaixo do peso",
    imc >= 18.5 & imc < 25  ~ "Normal",
    imc >= 25   & imc < 30  ~ "Sobrepeso",
    imc >= 30               ~ "Obesidade"
  )
}

# Combinando as duas fun√ß√µes
val <- imc(80, 1.75)
classificar_imc(val)
```

> **Princ√≠pio DRY** (Don't Repeat Yourself): se voc√™ copiou e colou c√≥digo mais de 2 vezes, provavelmente deveria criar uma fun√ß√£o!

---

## 3. Introdu√ß√£o ao Tidyverse (‚âà 45 min)

> Vamos aplicar `dplyr` no dataset **palmerpenguins** e criar um pequeno pipeline.

```{r}
library(dplyr)
library(palmerpenguins)

# Remover linhas com NAs nas colunas essenciais
peng <- penguins |>
  filter(!is.na(species),
         !is.na(bill_length_mm),
         !is.na(bill_depth_mm),
         !is.na(flipper_length_mm),
         !is.na(body_mass_g))

# Selecionar s√≥ o que precisamos
peng_sel <- peng |>
  select(species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

# Criar nova vari√°vel (raz√£o do bico) e reordenar
peng_feat <- peng_sel |>
  mutate(raz_bico = bill_length_mm / bill_depth_mm) |>
  arrange(species, desc(raz_bico))

# Resumo por esp√©cie
resumo <- peng_feat |>
  group_by(species) |>
  summarize(
    n = n(),
    media_flipper = mean(flipper_length_mm),
    sd_flipper    = sd(flipper_length_mm),
    media_massa   = mean(body_mass_g)
  )
resumo
```

### 3.1 Pipe: `%>%` vs. `|>`
```{r}
# Ambos funcionam; escolha um padr√£o para a turma.
# Exemplo com |> (pipe nativo do R >= 4.1):
penguins |>
  tidyr::drop_na(bill_length_mm) |>
  dplyr::summarize(media = mean(bill_length_mm))
```

---

## 4. Datas com `lubridate` (‚âà 10 min)

> Datas aparecem em **quase todos** os projetos. Vamos ilustrar rapidamente.

```{r}
library(lubridate)

# Cria√ß√£o e parsing
ymd("2025-11-18")
dmy("18/11/2025")
mdy("11-18-2025")

# Componentes
hoje <- today()
ano(hoje); mes(hoje); wday(hoje, label = TRUE, abbr = FALSE)

# Opera√ß√µes simples
hoje + days(14)
interval(ymd("2025-11-01"), ymd("2025-11-18"))
```

> **Integrando no pipeline**: quando houver colunas de data, transforme-as e derive **m√™s/ano** para agrega√ß√µes.

---

## 5. Exerc√≠cios Pr√°ticos (‚âà 20‚Äì25 min)

> **Dataset:** `palmerpenguins::penguins`

### Exerc√≠cio 1 ‚Äî Condicionais
1. Crie um vetor de 8 notas qualquer.  
2. Classifique com `ifelse()` como **Aprovado/Recupera√ß√£o** (corte em 7).  
3. Depois, crie uma classifica√ß√£o mais rica usando `case_when()` com 4 faixas.

```{r}
# Seu c√≥digo aqui
```

### Exerc√≠cio 2 ‚Äî Fun√ß√µes
1. Escreva uma fun√ß√£o `zscore(x)` que centraliza e escala (m√©dia 0, desvio 1).  
2. Aplique em `bill_length_mm` **removendo NAs** antes.  
3. Fa√ßa um segundo argumento opcional `na_rm = TRUE` dentro da fun√ß√£o.

```{r}
# Seu c√≥digo aqui
```

### Exerc√≠cio 3 ‚Äî Pipeline `dplyr`
1. Crie `peng3` filtrando linhas completas nas 4 medidas principais.  
2. Calcule, por esp√©cie, m√©dia e desvio da nadadeira (`flipper_length_mm`).  
3. Ordene do maior para o menor e mostre as 5 primeiras linhas.

```{r}
# Seu c√≥digo aqui
```

### Exerc√≠cio 4 ‚Äî Datas com `lubridate`
1. Crie um vetor com 5 datas em formato "dd/mm/aaaa".  
2. Converta com `dmy()` e extraia `month()` (com r√≥tulo).  
3. Some 30 dias √† primeira data e compute o intervalo at√© a √∫ltima.

```{r}
# Seu c√≥digo aqui
```

---

## 6. Boas Pr√°ticas e Debugging (‚âà 20 min)

- Use **nomes descritivos** em `snake_case`.
- Comente o **porqu√™** (n√£o s√≥ o que) no c√≥digo.
- Valide entradas em fun√ß√µes (`stop()` para erros previs√≠veis).
- Leia mensagens de erro **de baixo para cima** (stack trace).
- Mantenha scripts curtos e reutiliz√°veis.

### Ferramentas √∫teis
```{r}
# message(), warning(), stop() para sinalizar eventos
# browser() para inspecionar dentro de uma fun√ß√£o (quando eval=TRUE)
# traceback() ap√≥s um erro
```

> **IA como apoio (respons√°vel):** use ChatGPT/Claude para **explicar erros** e sugerir melhorias, mas sempre **entenda e teste** o c√≥digo.

---

## 7. Commit do Dia

1. Salve como `scripts/02_logica_funcoes.R` ou `materiais/dia2_logica_funcoes.Rmd` (este arquivo).  
2. No **Terminal do RStudio**:
```bash
git add scripts/02_logica_funcoes.R
git commit -m "Dia 2: l√≥gica, fun√ß√µes e tidyverse (com lubridate)"
git push origin main
```

> Lembre-se: voc√™ est√° trabalhando **no SEU fork**. O reposit√≥rio original permanece protegido.

---

## 8. Checklist de encerramento

- [ ] Dominou operadores l√≥gicos e relacionais
- [ ] Entendeu diferen√ßas entre `if/else`, `ifelse()` e `case_when()`
- [ ] Compreendeu por que vetoriza√ß√£o √© prefer√≠vel a loops
- [ ] Criou suas primeiras fun√ß√µes com valida√ß√£o
- [ ] Aplicou pipeline b√°sico com `dplyr`
- [ ] Explorou manipula√ß√£o de datas com `lubridate`
- [ ] Realizou commit e push no seu fork

---

## 9. Refer√™ncias r√°pidas
- **`dplyr` cheatsheet**: https://posit.co/resources/cheatsheets/  
- **R for Data Science (2e)**: https://r4ds.hadley.nz/  
- **Happy Git with R**: https://happygitwithr.com/  
- **palmerpenguins**: https://allisonhorst.github.io/palmerpenguins/
- **lubridate**: https://lubridate.tidyverse.org/

---

**Nos vemos no Dia 3 para transforma√ß√£o de dados e visualiza√ß√£o com ggplot2!** üöÄ